{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///re.min.js","webpack:///webpack/bootstrap c70a3457076c1c7b3671","webpack:///./src/index.js","webpack:///./src/re.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_re","_re2","_classCallCheck","instance","Constructor","TypeError","_escapeRegExp","pattern","replace","_isRegExp","object","Object","prototype","toString","_getRegExpFlags","regexp","match","_addFlags","flags","_uniqChars","RegExp","source","_cloneRegExp","str","arr","split","filter","value","index","list","indexOf","join","re","RE","defineProperty","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","Exec","input","nextIndex","callback","global","matches","exec","lastIndex","_reset","undefined","arguments","f","forEach","char","addFlags","map","invMatch","lastCharIndex","broke","slice","result","hasCallback","push","test","all","startPosition","substr","search","each","charIndex","indices","isRegExp","escape"],"mappings":"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","file":"re.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"re\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"re\"] = factory();\n\telse\n\t\troot[\"re\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"re\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"re\"] = factory();\n\telse\n\t\troot[\"re\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _re = __webpack_require__(1);\n\t\n\tvar _re2 = _interopRequireDefault(_re);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t// export default re;\n\t// http://stackoverflow.com/a/33683495/112731\n\tmodule.exports = _re2.default;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t *  re.js — RegExp API for Humans!\n\t *  @license MIT\n\t *  @copyright 2016, Onur Yıldırım (onur@cutepilot.com)\n\t */\n\t\n\t// --------------------------\n\t// HELPER METHODS\n\t// --------------------------\n\t\n\t/**\n\t *  Escapes regular expression characters within the given string.\n\t *  @private\n\t */\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _escapeRegExp(pattern) {\n\t    return pattern.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n\t}\n\t\n\t/**\n\t *  Checks whether the given object is a `RegExp`.\n\t *  @private\n\t */\n\tfunction _isRegExp(object) {\n\t    return Object.prototype.toString.call(object) === '[object RegExp]';\n\t}\n\t\n\t/**\n\t *  Gets the current flags from a `RegExp` instance.\n\t *  @private\n\t */\n\tfunction _getRegExpFlags(regexp) {\n\t    return regexp.toString().match(/[gimu]*$/)[0] || '';\n\t}\n\t\n\t/**\n\t *  Ensures that a `RegExp` instance has the given flag(s).\n\t *  @private\n\t */\n\tfunction _addFlags(regexp, flags) {\n\t    flags = _uniqChars(flags + _getRegExpFlags(regexp));\n\t    return new RegExp(regexp.source, flags);\n\t}\n\t\n\t/**\n\t *  Clones the given `RegExp` object.\n\t *  @private\n\t */\n\tfunction _cloneRegExp(regexp) {\n\t    return new RegExp(regexp.source, _getRegExpFlags(regexp));\n\t}\n\t\n\t/**\n\t *  Removes duplicate characters from the given string.\n\t *  @private\n\t */\n\tfunction _uniqChars(str) {\n\t    // we're safe to use .split here since we don't have unicode chars in 'gimu'.\n\t    // http://stackoverflow.com/a/38901550/112731\n\t    var arr = str.split('');\n\t    return arr.filter(function (value, index, list) {\n\t        return list.indexOf(value) === index;\n\t    }).join('');\n\t}\n\t\n\t// --------------------------\n\t// CLASS: Exec\n\t// --------------------------\n\t\n\t/**\n\t *  Internal `Exec` class used specifically for `re().exec()` method.\n\t *  @protected\n\t *  @inner\n\t *  @memberof! re\n\t */\n\t\n\tvar Exec = function () {\n\t\n\t    /**\n\t     *  Initiates a new instance of `Exec` class.\n\t     *  @private\n\t     *\n\t     *  @param {RegExp} regexp - RegExp instance.\n\t     *  @param {String} input - Source input string.\n\t     */\n\t    function Exec(regexp, input) {\n\t        _classCallCheck(this, Exec);\n\t\n\t        this.regexp = regexp;\n\t        this.input = input;\n\t        // this is used to store the .exec() call count/index\n\t        this.nextIndex = 0;\n\t    }\n\t\n\t    /**\n\t     *  Calls `RegExp#exec()` method once, for the current input string.\n\t     *  @private\n\t     *\n\t     *  @param {Function} callback\n\t     *         See {@link ?api=re#re~callback|`callback`}.\n\t     *  @returns {Exec} - Returns the current `Exec` instance (for\n\t     *  chainability and) so that `.next()` can be called repeatedly.\n\t     */\n\t\n\t\n\t    _createClass(Exec, [{\n\t        key: 'next',\n\t        value: function next(callback) {\n\t            if (!this.regexp.global) {\n\t                this.regexp = _addFlags(this.regexp, 'g');\n\t            }\n\t            var matches = this.regexp.exec(this.input);\n\t            callback(matches, this.nextIndex, this.regexp, matches.index);\n\t            // if exec matches are complete, reset `nextIndex` here. if not,\n\t            // user should call .reset() at the end of `.exec()` chain; if willing\n\t            // to reuse the RE instance.\n\t            if (this.regexp.lastIndex === 0) {\n\t                this.nextIndex = 0;\n\t            } else {\n\t                this.nextIndex++;\n\t            }\n\t            return this;\n\t        }\n\t\n\t        /**\n\t         *  Resets the last index of the internal `RegExp` instance.\n\t         *  This is for convenience that if the user wants to re-use the `Exec`\n\t         *  instance, they should call `.reset()` to reset the `.lastIndex`.\n\t         *  @private\n\t         *\n\t         *  @example\n\t         *  re(/\\w+/).exec(str)\n\t         *      .next(function (matches, index) {\n\t         *          console.log(index); // 0\n\t         *      })\n\t         *      .next(function (matches, index) {\n\t         *          console.log(index); // 1\n\t         *      })\n\t         *      .reset()\n\t         *      .next(function (matches, index) {\n\t         *          console.log(index); // 0\n\t         *      });\n\t         */\n\t\n\t    }, {\n\t        key: 'reset',\n\t        value: function reset() {\n\t            // reset exec count/index\n\t            this.nextIndex = 0;\n\t            // `.lastIndex` property is set only if the regular expression instance\n\t            // used the `g` flag to indicate a global search.\n\t            if (this.regexp.global && this.regexp.lastIndex) this.regexp.lastIndex = 0;\n\t            return this;\n\t        }\n\t    }]);\n\t\n\t    return Exec;\n\t}();\n\t\n\t// --------------------------\n\t// CLASS: RE\n\t// --------------------------\n\t\n\t/**\n\t *  `RE` internal class.\n\t *  @private\n\t *\n\t *  @license MIT\n\t *  @copyright 2016, Onur Yıldırım (onur@cutepilot.com)\n\t */\n\t\n\t\n\tvar RE = function () {\n\t\n\t    /**\n\t     *  Initiates a new instance of `RE`.\n\t     *  @private\n\t     *\n\t     *  @param {RegExp|String} pattern - Either a `RegExp` instance or\n\t     *  string pattern.\n\t     *  @param {String} [flags=\"\"] - Regular Expression flags. Ignored if a\n\t     *  `RegExp` instance is passed as the first argument.\n\t     */\n\t    function RE(pattern, flags) {\n\t        _classCallCheck(this, RE);\n\t\n\t        this.input = '';\n\t        this.regexp = !_isRegExp(pattern) ? new RegExp(pattern, flags || '')\n\t        // if a RegExp instance is passed, it will be untouched. flags,\n\t        // lastIndex, etc will be changed only on the internal clone, if\n\t        // needed.\n\t        : _cloneRegExp(pattern);\n\t\n\t        // reset `.lastIndex`. the passed regexp might be used previously.\n\t        this._reset();\n\t    }\n\t\n\t    /**\n\t     *  Resets the last index of the internal `RegExp` instance.\n\t     *  @private\n\t     */\n\t\n\t\n\t    _createClass(RE, [{\n\t        key: '_reset',\n\t        value: function _reset() {\n\t            // `.lastIndex` property is set only if the regular expression instance\n\t            // used the `g` flag to indicate a global search.\n\t            if (this.regexp.global && this.regexp.lastIndex) this.regexp.lastIndex = 0;\n\t        }\n\t\n\t        /**\n\t         *  Gets or sets the flags of the internal `RegExp` instance.\n\t         *  Omit the `value` argument to get the current flags.\n\t         *  @name re.flags\n\t         *  @function\n\t         *\n\t         *  @param {String} [value] - Regular Expression flags to be set.\n\t         *  @returns {String|void}\n\t         */\n\t\n\t    }, {\n\t        key: 'flags',\n\t        value: function flags(value) {\n\t            if (value === undefined) {\n\t                return _getRegExpFlags(this.regexp);\n\t            }\n\t            this.regexp = new RegExp(this.regexp.source, value);\n\t        }\n\t\n\t        /**\n\t         *  Ensures that the internal `RegExp` instance has the given flag(s).\n\t         *  You shouldn't need to call this. This method is mostly used internally\n\t         *  and made accessible as a convenience method.\n\t         *  @name re.addFlags\n\t         *  @function\n\t         *  @chainable\n\t         *\n\t         *  @param {String} flags - Regular Expression flags to be added.\n\t         *  @returns {re}\n\t         */\n\t\n\t    }, {\n\t        key: 'addFlags',\n\t        value: function addFlags(flags) {\n\t            this.regexp = _addFlags(this.regexp, flags);\n\t            return this;\n\t        }\n\t\n\t        /**\n\t         *  Removes the given flags from the internal `RegExp` instance.\n\t         *  You shouldn't need to call this. This is only made accessible as a\n\t         *  convenience method.\n\t         *  @name re.removeFlags\n\t         *  @function\n\t         *  @chainable\n\t         *\n\t         *  @param {String} [flags='gimu'] - Regular Expression flags to be removed.\n\t         *  If omitted, all flags are removed.\n\t         *  @returns {re}\n\t         */\n\t\n\t    }, {\n\t        key: 'removeFlags',\n\t        value: function removeFlags() {\n\t            var flags = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'gimu';\n\t\n\t            // if falsy, remove all flags\n\t            var f = this.flags();\n\t            flags.split('').forEach(function (char) {\n\t                f = f.replace(new RegExp(char, 'g'), '');\n\t            });\n\t            this.regexp = new RegExp(this.regexp.source, f);\n\t            return this;\n\t        }\n\t\n\t        /**\n\t         *  Gets a clone of the internal `RegExp` instance.\n\t         *  @name re.clone\n\t         *  @function\n\t         *\n\t         *  @returns {RegExp}\n\t         */\n\t\n\t    }, {\n\t        key: 'clone',\n\t        value: function clone() {\n\t            return _cloneRegExp(this.regexp);\n\t        }\n\t\n\t        /**\n\t         *  Like `Array#forEach`, invokes the given callback on each `RegExp#exec`\n\t         *  call. The `callback` is invoked with three arguments:\n\t         *  `(matches:Array, index:Number, regexp:RegExp)`.\n\t         *\n\t         *  Callback functions may exit iteration early by explicitly returning\n\t         *  `false`.\n\t         *\n\t         *  @name re.each\n\t         *  @function\n\t         *\n\t         *  @param {String} input - Source input string.\n\t         *  @param {Function} callback - The function invoked per iteration.\n\t         *         This takes four arguments.\n\t         *         See {@link ?api=re#re~callback|`callback`}.\n\t         *  @returns {void}\n\t         *\n\t         *  @example\n\t         *  var input = 'Peter Piper picked a peck of pickled peppers.';\n\t         *  re(/p\\w+/i).each(input, function (matches, index, regexp, charIndex) {\n\t         *      console.log(matches[0]); // logs words starting with a \"p\"\n\t         *  });\n\t         */\n\t\n\t    }, {\n\t        key: 'each',\n\t        value: function each(input, callback) {\n\t            // Note: Do not place the regular expression literal (or RegExp\n\t            // constructor) within the while condition or it will create an infinite\n\t            // loop if there is a match due to the lastIndex property being reset\n\t            // upon each iteration. Also be sure that the global flag is set or a\n\t            // loop will occur here either.\n\t            if (!this.regexp.global) this.addFlags('g');\n\t            var matches = void 0,\n\t                index = 0;\n\t            while ((matches = this.regexp.exec(input)) !== null) {\n\t                if (callback(matches, index, this.regexp, matches.index) === false) break;\n\t                index++;\n\t            }\n\t            // reset when we're done!\n\t            this._reset();\n\t        }\n\t\n\t        /**\n\t         *  Like `re#each` except that it iterates over matches of collection from\n\t         *  right to left (in other words, last to first).\n\t         *\n\t         *  Callback functions may exit iteration early by explicitly returning\n\t         *  `false`.\n\t         *\n\t         *  @name re.eachRight\n\t         *  @function\n\t         *\n\t         *  @param {String} input - Source input string.\n\t         *  @param {Function} callback - The function invoked per iteration.\n\t         *         This takes four arguments.\n\t         *         See {@link ?api=re#re~callback|`callback`}.\n\t         *  @returns {void}\n\t         *\n\t         *  @example\n\t         *  var input = 'Peter Piper picked a peck of pickled peppers.';\n\t         *  re(/p\\w+/i).eachRight(input, function (matches, index) {\n\t         *      if (matches[0] === 'peck') {\n\t         *          console.log('exiting @', index); // —> exiting @ 3\n\t         *          // return early, no more iterations..\n\t         *          return false;\n\t         *      }\n\t         *  });\n\t         */\n\t\n\t    }, {\n\t        key: 'eachRight',\n\t        value: function eachRight(input, callback) {\n\t            var i = void 0,\n\t                arr = this.map(input);\n\t            for (i = arr.length - 1; i >= 0; i--) {\n\t                if (callback(arr[i], i, this.regexp) === false) break;\n\t            }\n\t        }\n\t\n\t        /**\n\t         *  Like `re#each` except that this will iterate over non-matched blocks.\n\t         *\n\t         *  Callback functions may exit iteration early by explicitly returning\n\t         *  `false`.\n\t         *\n\t         *  <b>Remark</b>: This is an experimental feature.\n\t         *\n\t         *  @name re.eachInverse\n\t         *  @function\n\t         *\n\t         *  @param {String} input - Source input string.\n\t         *  @param {Function} callback - The function invoked per iteration.\n\t         *         This takes four arguments.\n\t         *         See {@link ?api=re#re~callback|`callback`}.\n\t         *  @returns {void}\n\t         *\n\t         *  @example\n\t         *  var input = 'foo1bar2baz';\n\t         *  re(/\\d/i).eachInverse(input, function (matches, index) {\n\t         *      if (index === 1) {\n\t         *          console.log(matches[0]); // —> \"bar\"\n\t         *          // return early, no more iterations..\n\t         *          return false;\n\t         *      }\n\t         *  });\n\t         */\n\t\n\t    }, {\n\t        key: 'eachInverse',\n\t        value: function eachInverse(input, callback) {\n\t            if (!this.regexp.global) this.addFlags('g');\n\t            var invMatch = void 0,\n\t                matches = void 0,\n\t                lastCharIndex = -1,\n\t                index = 0,\n\t                broke = false;\n\t\n\t            // NOTE: `invMatch` will be a string but we'll make it an array for\n\t            // consistency with other methods.\n\t\n\t            while ((matches = this.regexp.exec(input)) !== null) {\n\t                // check if first match character is 0 or not\n\t                if (index === 0 && matches.index > 0) {\n\t                    // take the first offset as the first inverse match\n\t                    invMatch = input.slice(0, matches.index);\n\t                    broke = callback([invMatch], index, this.regexp, matches.index) === false;\n\t                    if (broke) break;\n\t                }\n\t                // this will run after the first iteration\n\t                if (lastCharIndex > 0) {\n\t                    invMatch = input.slice(lastCharIndex, matches.index);\n\t                    broke = callback([invMatch], index, this.regexp, matches.index) === false;\n\t                    if (broke) break;\n\t                }\n\t                // set the last character index of the current match for later use\n\t                lastCharIndex = matches.index + (matches[0] || '').length;\n\t                index++;\n\t            }\n\t            // check if we have remaining sub-string after the last exec match.\n\t            // we should run this only if user didn't break (return false) before.\n\t            if (!broke && lastCharIndex <= input.length - 1) {\n\t                invMatch = input.slice(lastCharIndex, input.length);\n\t                callback([invMatch], index, this.regexp, lastCharIndex);\n\t            }\n\t            // reset when we're done!\n\t            this._reset();\n\t        }\n\t\n\t        /**\n\t         *  Like `Array#map`, maps the results of each `RegExp#exec` iteration while\n\t         *  invoking the given callback function on each match.\n\t         *  @name re.map\n\t         *  @function\n\t         *\n\t         *  @param {String} input - Source input string.\n\t         *  @param {Function} [callback] - The function invoked per iteration.\n\t         *         This takes four arguments.\n\t         *         See {@link ?api=re#re~callback|`callback`}.\n\t         *         If omitted, `matches` will be returned on each iteration.\n\t         *         Note that each match is also an `Array` containing the entire\n\t         *         match result and any parentheses-captured matched results.\n\t         *  @returns {Array}\n\t         *           Array of mapped matches (modified via `callback` if defined).\n\t         *           Returns an empty `Array` if there were no matches.\n\t         *\n\t         *  @example\n\t         *  var mapped = re(/p\\w+/i).map(input, function (matches) {\n\t         *      return matches[0];\n\t         *  });\n\t         *  console.log(mapped);\n\t         *  // —> [\"Peter\", \"Piper\", \"picked\", \"peck\", \"pickled\", \"peppers\"]\n\t         */\n\t\n\t    }, {\n\t        key: 'map',\n\t        value: function map(input, callback) {\n\t            if (!this.regexp.global) this.addFlags('g');\n\t            var matches = void 0,\n\t                result = [],\n\t                index = 0,\n\t                hasCallback = typeof callback === 'function';\n\t            while ((matches = this.regexp.exec(input)) !== null) {\n\t                // each iteration returns an array, we'll pass that and the\n\t                // regexp instance to the invoked callback.\n\t                result.push(hasCallback ? callback(matches, index, this.regexp, matches.index) : matches);\n\t                index++;\n\t            }\n\t            return result;\n\t        }\n\t\n\t        /**\n\t         *  Gets all the matches within the given input string, at once.\n\t         *  Same as `re#map(input)` (with no callback) which returns all matches.\n\t         *  @name re.all\n\t         *  @function\n\t         *\n\t         *  @param {String} input - Source input string.\n\t         *  @returns {Array}\n\t         *           Array of matches. Returns an empty `Array` if there were no\n\t         *           matches. Note that each match is also an `Array` containing the\n\t         *           entire match result and any parentheses-captured matched results.\n\t         *\n\t         *  @example\n\t         *  re(/p\\w+/i).all('Peter picked peppers');\n\t         *  // —> [Array, Array, Array]\n\t         */\n\t\n\t    }, {\n\t        key: 'all',\n\t        value: function all(input) {\n\t            return this.map(input);\n\t        }\n\t\n\t        /**\n\t         *  Returns a chainable  object that provides a `.next()` method to be\n\t         *  called repeatedly, to re-execute the `RegExp` against the input string.\n\t         *\n\t         *  The `.next()` method takes a single `callback` argument.\n\t         *  See {@link ?api=re#re~callback|`callback`}.\n\t         *\n\t         *  @name re.exec\n\t         *  @function\n\t         *\n\t         *  @param {String} input - Source input string.\n\t         *  @returns {Exec}\n\t         *\n\t         *  @example\n\t         *  re(/p\\w+/i)\n\t         *      .exec('Peter picked peppers')\n\t         *      .next(function (matches, index) {\n\t         *          console.log(index + ':', matches[0]); // —> 0: \"Peter\"\n\t         *      })\n\t         *      .next(function (matches, index) {\n\t         *          console.log(index, ':', matches[0]); // —> 1: \"picked\"\n\t         *      })\n\t         *      ..\n\t         */\n\t\n\t    }, {\n\t        key: 'exec',\n\t        value: function exec(input) {\n\t            return new Exec(this.regexp, input);\n\t        }\n\t\n\t        /**\n\t         *  Executes a search for a match within the given input string.\n\t         *  Returns `true` or `false`.\n\t         *  @name re.test\n\t         *  @function\n\t         *\n\t         *  @param {String} input - Source input string.\n\t         *  @returns {Boolean}\n\t         *\n\t         *  @example\n\t         *  re(/p\\w+/i).test('Peter picked peppers'); // —> true\n\t         */\n\t\n\t    }, {\n\t        key: 'test',\n\t        value: function test(input) {\n\t            return this.regexp.test(input);\n\t        }\n\t\n\t        /**\n\t         *  Gets the global number of matches within the given input string.\n\t         *  @name re.count\n\t         *  @function\n\t         *\n\t         *  @param {String} input - Source input string.\n\t         *  @returns {Number}\n\t         *\n\t         *  @example\n\t         *  re(/p\\w+/i).count('Peter picked peppers'); // —> 3\n\t         */\n\t\n\t    }, {\n\t        key: 'count',\n\t        value: function count(input) {\n\t            return this.all(input).length;\n\t        }\n\t\n\t        /**\n\t         *  Similar to `String#match()`, retreives the matches within the given\n\t         *  input string.\n\t         *  @name re.match\n\t         *  @function\n\t         *\n\t         *  @param {String} input - Source input string.\n\t         *  @returns {Array<String>}\n\t         *           An Array containing the entire match result and any\n\t         *           parentheses-captured matched results, or `null` if there were\n\t         *           no matches.\n\t         *\n\t         *  @example\n\t         *  re(/p\\w+/i).match('Peter picked peppers');\n\t         *  // —> [\"Peter\", \"picked\", \"peppers\"]\n\t         */\n\t\n\t    }, {\n\t        key: 'match',\n\t        value: function match(input) {\n\t            return input.match(this.regexp) || [];\n\t        }\n\t\n\t        /**\n\t         *  Gets the first match within the given input string.\n\t         *  Returns `null` if not found.\n\t         *  @name re.first\n\t         *  @function\n\t         *\n\t         *  @param {String} input - Source input string.\n\t         *  @param {Number} [startPosition=0] - Character position index to start with.\n\t         *  @returns {Array}\n\t         *           First match. The returned array has the matched text as the\n\t         *           first item, and then one item for each capturing parenthesis\n\t         *           that matched containing the text that was captured.\n\t         *\n\t         *  @example\n\t         *  re(/p\\w+/i).first('Peter picked peppers')[0]; // —> \"Peter\"\n\t         */\n\t\n\t    }, {\n\t        key: 'first',\n\t        value: function first(input) {\n\t            var startPosition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\t\n\t            var matches = this.regexp.exec(input.substr(startPosition));\n\t            this._reset();\n\t            return matches || [];\n\t        }\n\t\n\t        /**\n\t         *  Gets the character position index of the first match against the given\n\t         *  input string.\n\t         *  @name re.firstIndex\n\t         *  @function\n\t         *\n\t         *  @param {String} input - Source input string.\n\t         *  @param {Number} [startPosition=0] - Character position index to start with.\n\t         *  @returns {Number} - Character position index of the first matched result.\n\t         *\n\t         *  @example\n\t         *  re(/p\\w+/i).firstIndex('Peter picked peppers'); // —> 0\n\t         */\n\t\n\t    }, {\n\t        key: 'firstIndex',\n\t        value: function firstIndex(input) {\n\t            var startPosition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\t\n\t            return input.substr(startPosition).search(this.regexp);\n\t        }\n\t\n\t        /**\n\t         *  Gets the match at the given (match) index within the given input string.\n\t         *  Returns `null` if not found.\n\t         *  @name re.nth\n\t         *  @function\n\t         *\n\t         *  @param {String} input - Source input string.\n\t         *  @param {Number} [startPosition=0] - Character position index to start with.\n\t         *  @returns {Array}\n\t         *           Match at the given index. The returned array has the matched\n\t         *           text as the first item, and then one item for each capturing\n\t         *           parenthesis that matched containing the text that was captured.\n\t         *\n\t         *  @example\n\t         *  re(/p\\w+/i).nth('Peter picked peppers', 1)[0]; // —> \"picked\"\n\t         */\n\t\n\t    }, {\n\t        key: 'nth',\n\t        value: function nth(input) {\n\t            var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\t            var startPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\t\n\t            input = input.substr(startPosition);\n\t            if (index < 0) return null;\n\t            var result = this.all(input);\n\t            if (!result.length || index >= result.length) return null;\n\t            return result[index];\n\t        }\n\t\n\t        /**\n\t         *  Gets the last match within the given input string.\n\t         *  Returns `null` if not found.\n\t         *  @name re.last\n\t         *  @function\n\t         *\n\t         *  @param {String} input - Source input string.\n\t         *  @param {Number} [startPosition=0] - Character position index to start with.\n\t         *  @returns {Array}\n\t         *           Last match. The returned array has the matched text as the\n\t         *           first item, and then one item for each capturing parenthesis\n\t         *           that matched containing the text that was captured.\n\t         *\n\t         *  @example\n\t         *  re(/p\\w+/i).last('Peter picked peppers')[0]; // —> \"peppers\"\n\t         */\n\t\n\t    }, {\n\t        key: 'last',\n\t        value: function last(input) {\n\t            var all = this.all(input);\n\t            return all.length ? all[all.length - 1] : null;\n\t        }\n\t\n\t        /**\n\t         *  Gets the character position index of the last match against the given\n\t         *  input string.\n\t         *  @name re.lastIndex\n\t         *  @function\n\t         *\n\t         *  @param {String} input - Source input string.\n\t         *  @param {Number} [startPosition=0] - Character position index to start with.\n\t         *  @returns {Number} - Character position index of the last matched result.\n\t         *\n\t         *  @example\n\t         *  re(/p\\w+/i).lastIndex('Peter picked peppers'); // —> 13\n\t         */\n\t\n\t    }, {\n\t        key: 'lastIndex',\n\t        value: function lastIndex(input) {\n\t            var startPosition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\t\n\t            var result = this.all(input);\n\t            if (result.length) {\n\t                var lastIndex = result[result.length - 1].index;\n\t                return lastIndex > startPosition ? lastIndex - startPosition : -1;\n\t            }\n\t            return -1;\n\t        }\n\t\n\t        /**\n\t         *  Gets character position indices of all the matches against the given\n\t         *  input string.\n\t         *  @name re.indices\n\t         *  @alias re.charIndices\n\t         *  @function\n\t         *\n\t         *  @param {String} input - Source input string.\n\t         *  @param {Number} [startPosition=0] - Character position index to start with.\n\t         *  @returns {Array<Number>}\n\t         *           An array of numbers that indicate all the matched character\n\t         *           position indices.\n\t         *\n\t         *  @example\n\t         *  re(/p\\w+/i).indices('Peter picked peppers');\n\t         *  // —> [0, 6, 13]\n\t         */\n\t\n\t    }, {\n\t        key: 'indices',\n\t        value: function indices(input) {\n\t            var startPosition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\t\n\t            var arr = [];\n\t            this.each(input, function (matches, index, regexp, charIndex) {\n\t                if (startPosition <= charIndex) arr.push(charIndex);\n\t            });\n\t            return arr;\n\t        }\n\t\n\t        /**\n\t         *  Alias of `re#indices`.\n\t         *  @private\n\t         */\n\t\n\t    }, {\n\t        key: 'charIndices',\n\t        value: function charIndices(input) {\n\t            var startPosition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\t\n\t            return this.indices(input, startPosition);\n\t        }\n\t    }]);\n\t\n\t    return RE;\n\t}();\n\t\n\t// --------------------------\n\t// re OBJECT\n\t// --------------------------\n\t\n\t/**\n\t *  `RegExp` API for Humans!\n\t *\n\t *  For example, if you place regular expression literal or `RegExp` constructor\n\t *  within a `while` condition, you'll hit an infinite loop if there is a match!\n\t *  (Because the `RegExp` instance is re-initiated every time; which resets\n\t *  `lastIndex` to `0`).\n\t *\n\t *  Or if you forget the `global` flag for a `RegExp#exec()` call in a `while`\n\t *  condition; you'll again, hit an infinite loop!\n\t *\n\t *  Using `re`, you don't need to deal with these.\n\t *\n\t *  `re` is a shorthand function for initializing an instance of the internal\n\t *  `RE` class. You can init an instance with a `RegExp` literal or just like\n\t *  the `RegExp` constructor, pass two string arguments for pattern and flags.\n\t *\n\t *  @name re\n\t *  @function\n\t *  @global\n\t *\n\t *  @param {RegExp|String} pattern - Either a `RegExp` instance or\n\t *  string pattern.\n\t *  @param {String} [flags=\"\"] - Regular Expression flags. Ignored if a\n\t *  `RegExp` instance is passed as the first argument.\n\t *  @returns {RE} - `RE` instance.\n\t *\n\t *  @example\n\t *  re(/\\w+/gm).test('input');\n\t *  // or\n\t *  re('\\\\w+', 'gm').test('input');\n\t */\n\t\n\t\n\tfunction re(pattern, flags) {\n\t    return new RE(pattern, flags);\n\t}\n\t\n\t/**\n\t *  Checks whether the given object is a `RegExp`.\n\t *  @function\n\t *\n\t *  @param {*} object - Object to be checked.\n\t *  @returns {Boolean}\n\t */\n\tre.isRegExp = _isRegExp;\n\t\n\t/**\n\t *  Escapes regular expression characters within the given string.\n\t *  @function\n\t *\n\t *  @param {String} pattern - Pattern string to be escaped.\n\t *  @returns {String}\n\t */\n\tre.escape = _escapeRegExp;\n\t\n\tre.RE = RE;\n\t\n\t// --------------------------\n\t// EXPORT\n\t// --------------------------\n\t\n\texports.default = re;\n\t\n\t// --------------------------\n\t// ADDITIONAL DOCUMENTATION\n\t// --------------------------\n\t\n\t/**\n\t *  Callback function to be passed as an argument to methods such as\n\t *  {@link ?api=re#re#each|`re#each`}, {@link ?api=re#re#map|`re#map`}, etc..\n\t *  This is invoked per `RegExp` iteration with the following signature:\n\t *\n\t *  `function (matches:Array, index:Number, regexp:RegExp, charIndex:Number) {...}`\n\t *\n\t *  @callback re~callback\n\t *\n\t *  @param {Array} [matches]\n\t *         An `Array` containing the entire match result and any\n\t *         parentheses-captured matched results.\n\t *  @param {Number} [index]\n\t *         Current match (iteration) index.\n\t *  @param {RegExp} [regexp]\n\t *         Internal `RegExp` instance being used through out the iteration.\n\t *  @param {Number} [charIndex]\n\t *         Character index of the matched string.\n\t *         Same as `regexp.lastIndex` or `matches.index`.\n\t */\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// re.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c70a3457076c1c7b3671","import re from './re';\n// export default re;\n// http://stackoverflow.com/a/33683495/112731\nmodule.exports = re;\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","'use strict';\n\n/**\n *  re.js — RegExp API for Humans!\n *  @license MIT\n *  @copyright 2016, Onur Yıldırım (onur@cutepilot.com)\n */\n\n// --------------------------\n// HELPER METHODS\n// --------------------------\n\n/**\n *  Escapes regular expression characters within the given string.\n *  @private\n */\nfunction _escapeRegExp(pattern) {\n    return pattern.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n}\n\n/**\n *  Checks whether the given object is a `RegExp`.\n *  @private\n */\nfunction _isRegExp(object) {\n    return Object.prototype.toString.call(object) === '[object RegExp]';\n}\n\n/**\n *  Gets the current flags from a `RegExp` instance.\n *  @private\n */\nfunction _getRegExpFlags(regexp) {\n    return regexp.toString().match(/[gimu]*$/)[0] || '';\n}\n\n/**\n *  Ensures that a `RegExp` instance has the given flag(s).\n *  @private\n */\nfunction _addFlags(regexp, flags) {\n    flags = _uniqChars(flags + _getRegExpFlags(regexp));\n    return new RegExp(regexp.source, flags);\n}\n\n/**\n *  Clones the given `RegExp` object.\n *  @private\n */\nfunction _cloneRegExp(regexp) {\n    return new RegExp(regexp.source, _getRegExpFlags(regexp));\n}\n\n/**\n *  Removes duplicate characters from the given string.\n *  @private\n */\nfunction _uniqChars(str) {\n    // we're safe to use .split here since we don't have unicode chars in 'gimu'.\n    // http://stackoverflow.com/a/38901550/112731\n    let arr = str.split('');\n    return arr.filter((value, index, list) => {\n        return list.indexOf(value) === index;\n    }).join('');\n}\n\n// --------------------------\n// CLASS: Exec\n// --------------------------\n\n/**\n *  Internal `Exec` class used specifically for `re().exec()` method.\n *  @protected\n *  @inner\n *  @memberof! re\n */\nclass Exec {\n\n    /**\n     *  Initiates a new instance of `Exec` class.\n     *  @private\n     *\n     *  @param {RegExp} regexp - RegExp instance.\n     *  @param {String} input - Source input string.\n     */\n    constructor(regexp, input) {\n        this.regexp = regexp;\n        this.input = input;\n        // this is used to store the .exec() call count/index\n        this.nextIndex = 0;\n    }\n\n    /**\n     *  Calls `RegExp#exec()` method once, for the current input string.\n     *  @private\n     *\n     *  @param {Function} callback\n     *         See {@link ?api=re#re~callback|`callback`}.\n     *  @returns {Exec} - Returns the current `Exec` instance (for\n     *  chainability and) so that `.next()` can be called repeatedly.\n     */\n    next(callback) {\n        if (!this.regexp.global) {\n            this.regexp = _addFlags(this.regexp, 'g');\n        }\n        let matches = this.regexp.exec(this.input);\n        callback(matches, this.nextIndex, this.regexp, matches.index);\n        // if exec matches are complete, reset `nextIndex` here. if not,\n        // user should call .reset() at the end of `.exec()` chain; if willing\n        // to reuse the RE instance.\n        if (this.regexp.lastIndex === 0) {\n            this.nextIndex = 0;\n        } else {\n            this.nextIndex++;\n        }\n        return this;\n    }\n\n    /**\n     *  Resets the last index of the internal `RegExp` instance.\n     *  This is for convenience that if the user wants to re-use the `Exec`\n     *  instance, they should call `.reset()` to reset the `.lastIndex`.\n     *  @private\n     *\n     *  @example\n     *  re(/\\w+/).exec(str)\n     *      .next(function (matches, index) {\n     *          console.log(index); // 0\n     *      })\n     *      .next(function (matches, index) {\n     *          console.log(index); // 1\n     *      })\n     *      .reset()\n     *      .next(function (matches, index) {\n     *          console.log(index); // 0\n     *      });\n     */\n    reset() {\n        // reset exec count/index\n        this.nextIndex = 0;\n        // `.lastIndex` property is set only if the regular expression instance\n        // used the `g` flag to indicate a global search.\n        if (this.regexp.global && this.regexp.lastIndex) this.regexp.lastIndex = 0;\n        return this;\n    }\n}\n\n// --------------------------\n// CLASS: RE\n// --------------------------\n\n/**\n *  `RE` internal class.\n *  @private\n *\n *  @license MIT\n *  @copyright 2016, Onur Yıldırım (onur@cutepilot.com)\n */\nclass RE {\n\n    /**\n     *  Initiates a new instance of `RE`.\n     *  @private\n     *\n     *  @param {RegExp|String} pattern - Either a `RegExp` instance or\n     *  string pattern.\n     *  @param {String} [flags=\"\"] - Regular Expression flags. Ignored if a\n     *  `RegExp` instance is passed as the first argument.\n     */\n    constructor(pattern, flags) {\n        this.input = '';\n        this.regexp = !_isRegExp(pattern)\n            ? new RegExp(pattern, flags || '')\n            // if a RegExp instance is passed, it will be untouched. flags,\n            // lastIndex, etc will be changed only on the internal clone, if\n            // needed.\n            : _cloneRegExp(pattern);\n\n        // reset `.lastIndex`. the passed regexp might be used previously.\n        this._reset();\n    }\n\n    /**\n     *  Resets the last index of the internal `RegExp` instance.\n     *  @private\n     */\n    _reset() {\n        // `.lastIndex` property is set only if the regular expression instance\n        // used the `g` flag to indicate a global search.\n        if (this.regexp.global && this.regexp.lastIndex) this.regexp.lastIndex = 0;\n    }\n\n    /**\n     *  Gets or sets the flags of the internal `RegExp` instance.\n     *  Omit the `value` argument to get the current flags.\n     *  @name re.flags\n     *  @function\n     *\n     *  @param {String} [value] - Regular Expression flags to be set.\n     *  @returns {String|void}\n     */\n    flags(value) {\n        if (value === undefined) {\n            return _getRegExpFlags(this.regexp);\n        }\n        this.regexp = new RegExp(this.regexp.source, value);\n    }\n\n    /**\n     *  Ensures that the internal `RegExp` instance has the given flag(s).\n     *  You shouldn't need to call this. This method is mostly used internally\n     *  and made accessible as a convenience method.\n     *  @name re.addFlags\n     *  @function\n     *  @chainable\n     *\n     *  @param {String} flags - Regular Expression flags to be added.\n     *  @returns {re}\n     */\n    addFlags(flags) {\n        this.regexp = _addFlags(this.regexp, flags);\n        return this;\n    }\n\n    /**\n     *  Removes the given flags from the internal `RegExp` instance.\n     *  You shouldn't need to call this. This is only made accessible as a\n     *  convenience method.\n     *  @name re.removeFlags\n     *  @function\n     *  @chainable\n     *\n     *  @param {String} [flags='gimu'] - Regular Expression flags to be removed.\n     *  If omitted, all flags are removed.\n     *  @returns {re}\n     */\n    removeFlags(flags = 'gimu') {\n        // if falsy, remove all flags\n        let f = this.flags();\n        flags.split('').forEach(char => {\n            f = f.replace(new RegExp(char, 'g'), '');\n        });\n        this.regexp = new RegExp(this.regexp.source, f);\n        return this;\n    }\n\n    /**\n     *  Gets a clone of the internal `RegExp` instance.\n     *  @name re.clone\n     *  @function\n     *\n     *  @returns {RegExp}\n     */\n    clone() {\n        return _cloneRegExp(this.regexp);\n    }\n\n    /**\n     *  Like `Array#forEach`, invokes the given callback on each `RegExp#exec`\n     *  call. The `callback` is invoked with three arguments:\n     *  `(matches:Array, index:Number, regexp:RegExp)`.\n     *\n     *  Callback functions may exit iteration early by explicitly returning\n     *  `false`.\n     *\n     *  @name re.each\n     *  @function\n     *\n     *  @param {String} input - Source input string.\n     *  @param {Function} callback - The function invoked per iteration.\n     *         This takes four arguments.\n     *         See {@link ?api=re#re~callback|`callback`}.\n     *  @returns {void}\n     *\n     *  @example\n     *  var input = 'Peter Piper picked a peck of pickled peppers.';\n     *  re(/p\\w+/i).each(input, function (matches, index, regexp, charIndex) {\n     *      console.log(matches[0]); // logs words starting with a \"p\"\n     *  });\n     */\n    each(input, callback) {\n        // Note: Do not place the regular expression literal (or RegExp\n        // constructor) within the while condition or it will create an infinite\n        // loop if there is a match due to the lastIndex property being reset\n        // upon each iteration. Also be sure that the global flag is set or a\n        // loop will occur here either.\n        if (!this.regexp.global) this.addFlags('g');\n        let matches,\n            index = 0;\n        while ((matches = this.regexp.exec(input)) !== null) {\n            if (callback(matches, index, this.regexp, matches.index) === false) break;\n            index++;\n        }\n        // reset when we're done!\n        this._reset();\n    }\n\n    /**\n     *  Like `re#each` except that it iterates over matches of collection from\n     *  right to left (in other words, last to first).\n     *\n     *  Callback functions may exit iteration early by explicitly returning\n     *  `false`.\n     *\n     *  @name re.eachRight\n     *  @function\n     *\n     *  @param {String} input - Source input string.\n     *  @param {Function} callback - The function invoked per iteration.\n     *         This takes four arguments.\n     *         See {@link ?api=re#re~callback|`callback`}.\n     *  @returns {void}\n     *\n     *  @example\n     *  var input = 'Peter Piper picked a peck of pickled peppers.';\n     *  re(/p\\w+/i).eachRight(input, function (matches, index) {\n     *      if (matches[0] === 'peck') {\n     *          console.log('exiting @', index); // —> exiting @ 3\n     *          // return early, no more iterations..\n     *          return false;\n     *      }\n     *  });\n     */\n    eachRight(input, callback) {\n        let i,\n            arr = this.map(input);\n        for (i = arr.length - 1; i >= 0; i--) {\n            if (callback(arr[i], i, this.regexp) === false) break;\n        }\n    }\n\n    /**\n     *  Like `re#each` except that this will iterate over non-matched blocks.\n     *\n     *  Callback functions may exit iteration early by explicitly returning\n     *  `false`.\n     *\n     *  <b>Remark</b>: This is an experimental feature.\n     *\n     *  @name re.eachInverse\n     *  @function\n     *\n     *  @param {String} input - Source input string.\n     *  @param {Function} callback - The function invoked per iteration.\n     *         This takes four arguments.\n     *         See {@link ?api=re#re~callback|`callback`}.\n     *  @returns {void}\n     *\n     *  @example\n     *  var input = 'foo1bar2baz';\n     *  re(/\\d/i).eachInverse(input, function (matches, index) {\n     *      if (index === 1) {\n     *          console.log(matches[0]); // —> \"bar\"\n     *          // return early, no more iterations..\n     *          return false;\n     *      }\n     *  });\n     */\n    eachInverse(input, callback) {\n        if (!this.regexp.global) this.addFlags('g');\n        let invMatch,\n            matches,\n            lastCharIndex = -1,\n            index = 0,\n            broke = false;\n\n        // NOTE: `invMatch` will be a string but we'll make it an array for\n        // consistency with other methods.\n\n        while ((matches = this.regexp.exec(input)) !== null) {\n            // check if first match character is 0 or not\n            if (index === 0 && matches.index > 0) {\n                // take the first offset as the first inverse match\n                invMatch = input.slice(0, matches.index);\n                broke = callback([invMatch], index, this.regexp, matches.index) === false;\n                if (broke) break;\n            }\n            // this will run after the first iteration\n            if (lastCharIndex > 0) {\n                invMatch = input.slice(lastCharIndex, matches.index);\n                broke = callback([invMatch], index, this.regexp, matches.index) === false;\n                if (broke) break;\n            }\n            // set the last character index of the current match for later use\n            lastCharIndex = matches.index + (matches[0] || '').length;\n            index++;\n        }\n        // check if we have remaining sub-string after the last exec match.\n        // we should run this only if user didn't break (return false) before.\n        if (!broke && lastCharIndex <= input.length - 1) {\n            invMatch = input.slice(lastCharIndex, input.length);\n            callback([invMatch], index, this.regexp, lastCharIndex);\n        }\n        // reset when we're done!\n        this._reset();\n    }\n\n    /**\n     *  Like `Array#map`, maps the results of each `RegExp#exec` iteration while\n     *  invoking the given callback function on each match.\n     *  @name re.map\n     *  @function\n     *\n     *  @param {String} input - Source input string.\n     *  @param {Function} [callback] - The function invoked per iteration.\n     *         This takes four arguments.\n     *         See {@link ?api=re#re~callback|`callback`}.\n     *         If omitted, `matches` will be returned on each iteration.\n     *         Note that each match is also an `Array` containing the entire\n     *         match result and any parentheses-captured matched results.\n     *  @returns {Array}\n     *           Array of mapped matches (modified via `callback` if defined).\n     *           Returns an empty `Array` if there were no matches.\n     *\n     *  @example\n     *  var mapped = re(/p\\w+/i).map(input, function (matches) {\n     *      return matches[0];\n     *  });\n     *  console.log(mapped);\n     *  // —> [\"Peter\", \"Piper\", \"picked\", \"peck\", \"pickled\", \"peppers\"]\n     */\n    map(input, callback) {\n        if (!this.regexp.global) this.addFlags('g');\n        let matches,\n            result = [],\n            index = 0,\n            hasCallback = typeof callback === 'function';\n        while ((matches = this.regexp.exec(input)) !== null) {\n            // each iteration returns an array, we'll pass that and the\n            // regexp instance to the invoked callback.\n            result.push(\n                hasCallback\n                    ? callback(matches, index, this.regexp, matches.index)\n                    : matches\n            );\n            index++;\n        }\n        return result;\n    }\n\n    /**\n     *  Gets all the matches within the given input string, at once.\n     *  Same as `re#map(input)` (with no callback) which returns all matches.\n     *  @name re.all\n     *  @function\n     *\n     *  @param {String} input - Source input string.\n     *  @returns {Array}\n     *           Array of matches. Returns an empty `Array` if there were no\n     *           matches. Note that each match is also an `Array` containing the\n     *           entire match result and any parentheses-captured matched results.\n     *\n     *  @example\n     *  re(/p\\w+/i).all('Peter picked peppers');\n     *  // —> [Array, Array, Array]\n     */\n    all(input) {\n        return this.map(input);\n    }\n\n    /**\n     *  Returns a chainable  object that provides a `.next()` method to be\n     *  called repeatedly, to re-execute the `RegExp` against the input string.\n     *\n     *  The `.next()` method takes a single `callback` argument.\n     *  See {@link ?api=re#re~callback|`callback`}.\n     *\n     *  @name re.exec\n     *  @function\n     *\n     *  @param {String} input - Source input string.\n     *  @returns {Exec}\n     *\n     *  @example\n     *  re(/p\\w+/i)\n     *      .exec('Peter picked peppers')\n     *      .next(function (matches, index) {\n     *          console.log(index + ':', matches[0]); // —> 0: \"Peter\"\n     *      })\n     *      .next(function (matches, index) {\n     *          console.log(index, ':', matches[0]); // —> 1: \"picked\"\n     *      })\n     *      ..\n     */\n    exec(input) {\n        return new Exec(this.regexp, input);\n    }\n\n    /**\n     *  Executes a search for a match within the given input string.\n     *  Returns `true` or `false`.\n     *  @name re.test\n     *  @function\n     *\n     *  @param {String} input - Source input string.\n     *  @returns {Boolean}\n     *\n     *  @example\n     *  re(/p\\w+/i).test('Peter picked peppers'); // —> true\n     */\n    test(input) {\n        return this.regexp.test(input);\n    }\n\n    /**\n     *  Gets the global number of matches within the given input string.\n     *  @name re.count\n     *  @function\n     *\n     *  @param {String} input - Source input string.\n     *  @returns {Number}\n     *\n     *  @example\n     *  re(/p\\w+/i).count('Peter picked peppers'); // —> 3\n     */\n    count(input) {\n        return this.all(input).length;\n    }\n\n    /**\n     *  Similar to `String#match()`, retreives the matches within the given\n     *  input string.\n     *  @name re.match\n     *  @function\n     *\n     *  @param {String} input - Source input string.\n     *  @returns {Array<String>}\n     *           An Array containing the entire match result and any\n     *           parentheses-captured matched results, or `null` if there were\n     *           no matches.\n     *\n     *  @example\n     *  re(/p\\w+/i).match('Peter picked peppers');\n     *  // —> [\"Peter\", \"picked\", \"peppers\"]\n     */\n    match(input) {\n        return input.match(this.regexp) || [];\n    }\n\n    /**\n     *  Gets the first match within the given input string.\n     *  Returns `null` if not found.\n     *  @name re.first\n     *  @function\n     *\n     *  @param {String} input - Source input string.\n     *  @param {Number} [startPosition=0] - Character position index to start with.\n     *  @returns {Array}\n     *           First match. The returned array has the matched text as the\n     *           first item, and then one item for each capturing parenthesis\n     *           that matched containing the text that was captured.\n     *\n     *  @example\n     *  re(/p\\w+/i).first('Peter picked peppers')[0]; // —> \"Peter\"\n     */\n    first(input, startPosition = 0) {\n        let matches = this.regexp.exec(input.substr(startPosition));\n        this._reset();\n        return matches || [];\n    }\n\n    /**\n     *  Gets the character position index of the first match against the given\n     *  input string.\n     *  @name re.firstIndex\n     *  @function\n     *\n     *  @param {String} input - Source input string.\n     *  @param {Number} [startPosition=0] - Character position index to start with.\n     *  @returns {Number} - Character position index of the first matched result.\n     *\n     *  @example\n     *  re(/p\\w+/i).firstIndex('Peter picked peppers'); // —> 0\n     */\n    firstIndex(input, startPosition = 0) {\n        return input.substr(startPosition).search(this.regexp);\n    }\n\n    /**\n     *  Gets the match at the given (match) index within the given input string.\n     *  Returns `null` if not found.\n     *  @name re.nth\n     *  @function\n     *\n     *  @param {String} input - Source input string.\n     *  @param {Number} [startPosition=0] - Character position index to start with.\n     *  @returns {Array}\n     *           Match at the given index. The returned array has the matched\n     *           text as the first item, and then one item for each capturing\n     *           parenthesis that matched containing the text that was captured.\n     *\n     *  @example\n     *  re(/p\\w+/i).nth('Peter picked peppers', 1)[0]; // —> \"picked\"\n     */\n    nth(input, index = 0, startPosition = 0) {\n        input = input.substr(startPosition);\n        if (index < 0) return null;\n        let result = this.all(input);\n        if (!result.length || index >= result.length) return null;\n        return result[index];\n    }\n\n    /**\n     *  Gets the last match within the given input string.\n     *  Returns `null` if not found.\n     *  @name re.last\n     *  @function\n     *\n     *  @param {String} input - Source input string.\n     *  @param {Number} [startPosition=0] - Character position index to start with.\n     *  @returns {Array}\n     *           Last match. The returned array has the matched text as the\n     *           first item, and then one item for each capturing parenthesis\n     *           that matched containing the text that was captured.\n     *\n     *  @example\n     *  re(/p\\w+/i).last('Peter picked peppers')[0]; // —> \"peppers\"\n     */\n    last(input) {\n        let all = this.all(input);\n        return all.length\n            ? all[all.length - 1]\n            : null;\n    }\n\n    /**\n     *  Gets the character position index of the last match against the given\n     *  input string.\n     *  @name re.lastIndex\n     *  @function\n     *\n     *  @param {String} input - Source input string.\n     *  @param {Number} [startPosition=0] - Character position index to start with.\n     *  @returns {Number} - Character position index of the last matched result.\n     *\n     *  @example\n     *  re(/p\\w+/i).lastIndex('Peter picked peppers'); // —> 13\n     */\n    lastIndex(input, startPosition = 0) {\n        let result = this.all(input);\n        if (result.length) {\n            let lastIndex = result[result.length - 1].index;\n            return lastIndex > startPosition\n                ? lastIndex - startPosition\n                : -1;\n        }\n        return -1;\n    }\n\n    /**\n     *  Gets character position indices of all the matches against the given\n     *  input string.\n     *  @name re.indices\n     *  @alias re.charIndices\n     *  @function\n     *\n     *  @param {String} input - Source input string.\n     *  @param {Number} [startPosition=0] - Character position index to start with.\n     *  @returns {Array<Number>}\n     *           An array of numbers that indicate all the matched character\n     *           position indices.\n     *\n     *  @example\n     *  re(/p\\w+/i).indices('Peter picked peppers');\n     *  // —> [0, 6, 13]\n     */\n    indices(input, startPosition = 0) {\n        let arr = [];\n        this.each(input, (matches, index, regexp, charIndex) => {\n            if (startPosition <= charIndex) arr.push(charIndex);\n        });\n        return arr;\n    }\n\n    /**\n     *  Alias of `re#indices`.\n     *  @private\n     */\n    charIndices(input, startPosition = 0) {\n        return this.indices(input, startPosition);\n    }\n}\n\n// --------------------------\n// re OBJECT\n// --------------------------\n\n/**\n *  `RegExp` API for Humans!\n *\n *  For example, if you place regular expression literal or `RegExp` constructor\n *  within a `while` condition, you'll hit an infinite loop if there is a match!\n *  (Because the `RegExp` instance is re-initiated every time; which resets\n *  `lastIndex` to `0`).\n *\n *  Or if you forget the `global` flag for a `RegExp#exec()` call in a `while`\n *  condition; you'll again, hit an infinite loop!\n *\n *  Using `re`, you don't need to deal with these.\n *\n *  `re` is a shorthand function for initializing an instance of the internal\n *  `RE` class. You can init an instance with a `RegExp` literal or just like\n *  the `RegExp` constructor, pass two string arguments for pattern and flags.\n *\n *  @name re\n *  @function\n *  @global\n *\n *  @param {RegExp|String} pattern - Either a `RegExp` instance or\n *  string pattern.\n *  @param {String} [flags=\"\"] - Regular Expression flags. Ignored if a\n *  `RegExp` instance is passed as the first argument.\n *  @returns {RE} - `RE` instance.\n *\n *  @example\n *  re(/\\w+/gm).test('input');\n *  // or\n *  re('\\\\w+', 'gm').test('input');\n */\nfunction re(pattern, flags) {\n    return new RE(pattern, flags);\n}\n\n/**\n *  Checks whether the given object is a `RegExp`.\n *  @function\n *\n *  @param {*} object - Object to be checked.\n *  @returns {Boolean}\n */\nre.isRegExp = _isRegExp;\n\n/**\n *  Escapes regular expression characters within the given string.\n *  @function\n *\n *  @param {String} pattern - Pattern string to be escaped.\n *  @returns {String}\n */\nre.escape = _escapeRegExp;\n\nre.RE = RE;\n\n// --------------------------\n// EXPORT\n// --------------------------\n\nexport default re;\n\n// --------------------------\n// ADDITIONAL DOCUMENTATION\n// --------------------------\n\n/**\n *  Callback function to be passed as an argument to methods such as\n *  {@link ?api=re#re#each|`re#each`}, {@link ?api=re#re#map|`re#map`}, etc..\n *  This is invoked per `RegExp` iteration with the following signature:\n *\n *  `function (matches:Array, index:Number, regexp:RegExp, charIndex:Number) {...}`\n *\n *  @callback re~callback\n *\n *  @param {Array} [matches]\n *         An `Array` containing the entire match result and any\n *         parentheses-captured matched results.\n *  @param {Number} [index]\n *         Current match (iteration) index.\n *  @param {RegExp} [regexp]\n *         Internal `RegExp` instance being used through out the iteration.\n *  @param {Number} [charIndex]\n *         Character index of the matched string.\n *         Same as `regexp.lastIndex` or `matches.index`.\n */\n\n\n\n// WEBPACK FOOTER //\n// ./src/re.js"],"sourceRoot":""}