{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 8938fafc0d7ad16654fa","webpack:///./src/index.js","webpack:///./src/re.js"],"names":["module","exports","_escapeRegExp","pattern","replace","_isRegExp","object","Object","prototype","toString","call","_getRegExpFlags","regexp","match","_addFlags","flags","_uniqChars","RegExp","source","_cloneRegExp","str","arr","split","filter","value","index","list","indexOf","join","Exec","input","nextIndex","callback","global","matches","exec","lastIndex","RE","_reset","undefined","f","forEach","char","addFlags","i","map","length","invMatch","lastCharIndex","broke","slice","result","hasCallback","push","test","all","startPosition","substr","search","each","charIndex","indices","re","isRegExp","escape"],"mappings":"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","file":"re.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"re\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"re\"] = factory();\n\telse\n\t\troot[\"re\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 8938fafc0d7ad16654fa","import re from './re';\n// export default re;\n// http://stackoverflow.com/a/33683495/112731\nmodule.exports = re;\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","'use strict';\n\n/**\n *  re.js — RegExp API for Humans!\n *  @license MIT\n *  @copyright 2016, Onur Yıldırım (onur@cutepilot.com)\n */\n\n// --------------------------\n// HELPER METHODS\n// --------------------------\n\n/**\n *  Escapes regular expression characters within the given string.\n *  @private\n */\nfunction _escapeRegExp(pattern) {\n    return pattern.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n}\n\n/**\n *  Checks whether the given object is a `RegExp`.\n *  @private\n */\nfunction _isRegExp(object) {\n    return Object.prototype.toString.call(object) === '[object RegExp]';\n}\n\n/**\n *  Gets the current flags from a `RegExp` instance.\n *  @private\n */\nfunction _getRegExpFlags(regexp) {\n    return regexp.toString().match(/[gimu]*$/)[0] || '';\n}\n\n/**\n *  Ensures that a `RegExp` instance has the given flag(s).\n *  @private\n */\nfunction _addFlags(regexp, flags) {\n    flags = _uniqChars(flags + _getRegExpFlags(regexp));\n    return new RegExp(regexp.source, flags);\n}\n\n/**\n *  Clones the given `RegExp` object.\n *  @private\n */\nfunction _cloneRegExp(regexp) {\n    return new RegExp(regexp.source, _getRegExpFlags(regexp));\n}\n\n/**\n *  Removes duplicate characters from the given string.\n *  @private\n */\nfunction _uniqChars(str) {\n    // we're safe to use .split here since we don't have unicode chars in 'gimu'.\n    // http://stackoverflow.com/a/38901550/112731\n    let arr = str.split('');\n    return arr.filter((value, index, list) => {\n        return list.indexOf(value) === index;\n    }).join('');\n}\n\n// --------------------------\n// CLASS: Exec\n// --------------------------\n\n/**\n *  Internal `Exec` class used specifically for `re().exec()` method.\n *  @protected\n *  @inner\n *  @memberof! re\n */\nclass Exec {\n\n    /**\n     *  Initiates a new instance of `Exec` class.\n     *  @private\n     *\n     *  @param {RegExp} regexp - RegExp instance.\n     *  @param {String} input - Source input string.\n     */\n    constructor(regexp, input) {\n        this.regexp = regexp;\n        this.input = input;\n        // this is used to store the .exec() call count/index\n        this.nextIndex = 0;\n    }\n\n    /**\n     *  Calls `RegExp#exec()` method once, for the current input string.\n     *  @private\n     *\n     *  @param {Function} callback\n     *         See {@link ?api=re#re~callback|`callback`}.\n     *  @returns {Exec} - Returns the current `Exec` instance (for\n     *  chainability and) so that `.next()` can be called repeatedly.\n     */\n    next(callback) {\n        if (!this.regexp.global) {\n            this.regexp = _addFlags(this.regexp, 'g');\n        }\n        let matches = this.regexp.exec(this.input);\n        callback(matches, this.nextIndex, this.regexp, matches.index);\n        // if exec matches are complete, reset `nextIndex` here. if not,\n        // user should call .reset() at the end of `.exec()` chain; if willing\n        // to reuse the RE instance.\n        if (this.regexp.lastIndex === 0) {\n            this.nextIndex = 0;\n        } else {\n            this.nextIndex++;\n        }\n        return this;\n    }\n\n    /**\n     *  Resets the last index of the internal `RegExp` instance.\n     *  This is for convenience that if the user wants to re-use the `Exec`\n     *  instance, they should call `.reset()` to reset the `.lastIndex`.\n     *  @private\n     *\n     *  @example\n     *  re(/\\w+/).exec(str)\n     *      .next(function (matches, index) {\n     *          console.log(index); // 0\n     *      })\n     *      .next(function (matches, index) {\n     *          console.log(index); // 1\n     *      })\n     *      .reset()\n     *      .next(function (matches, index) {\n     *          console.log(index); // 0\n     *      });\n     */\n    reset() {\n        // reset exec count/index\n        this.nextIndex = 0;\n        // `.lastIndex` property is set only if the regular expression instance\n        // used the `g` flag to indicate a global search.\n        if (this.regexp.global && this.regexp.lastIndex) this.regexp.lastIndex = 0;\n        return this;\n    }\n}\n\n// --------------------------\n// CLASS: RE\n// --------------------------\n\n/**\n *  `RE` internal class.\n *  @private\n *\n *  @license MIT\n *  @copyright 2016, Onur Yıldırım (onur@cutepilot.com)\n */\nclass RE {\n\n    /**\n     *  Initiates a new instance of `RE`.\n     *  @private\n     *\n     *  @param {RegExp|String} pattern - Either a `RegExp` instance or\n     *  string pattern.\n     *  @param {String} [flags=\"\"] - Regular Expression flags. Ignored if a\n     *  `RegExp` instance is passed as the first argument.\n     */\n    constructor(pattern, flags) {\n        this.input = '';\n        this.regexp = !_isRegExp(pattern)\n            ? new RegExp(pattern, flags || '')\n            // if a RegExp instance is passed, it will be untouched. flags,\n            // lastIndex, etc will be changed only on the internal clone, if\n            // needed.\n            : _cloneRegExp(pattern);\n\n        // reset `.lastIndex`. the passed regexp might be used previously.\n        this._reset();\n    }\n\n    /**\n     *  Resets the last index of the internal `RegExp` instance.\n     *  @private\n     */\n    _reset() {\n        // `.lastIndex` property is set only if the regular expression instance\n        // used the `g` flag to indicate a global search.\n        if (this.regexp.global && this.regexp.lastIndex) this.regexp.lastIndex = 0;\n    }\n\n    /**\n     *  Gets or sets the flags of the internal `RegExp` instance.\n     *  Omit the `value` argument to get the current flags.\n     *  @name re.flags\n     *  @function\n     *\n     *  @param {String} [value] - Regular Expression flags to be set.\n     *  @returns {String|void}\n     */\n    flags(value) {\n        if (value === undefined) {\n            return _getRegExpFlags(this.regexp);\n        }\n        this.regexp = new RegExp(this.regexp.source, value);\n    }\n\n    /**\n     *  Ensures that the internal `RegExp` instance has the given flag(s).\n     *  You shouldn't need to call this. This method is mostly used internally\n     *  and made accessible as a convenience method.\n     *  @name re.addFlags\n     *  @function\n     *  @chainable\n     *\n     *  @param {String} flags - Regular Expression flags to be added.\n     *  @returns {re}\n     */\n    addFlags(flags) {\n        this.regexp = _addFlags(this.regexp, flags);\n        return this;\n    }\n\n    /**\n     *  Removes the given flags from the internal `RegExp` instance.\n     *  You shouldn't need to call this. This is only made accessible as a\n     *  convenience method.\n     *  @name re.removeFlags\n     *  @function\n     *  @chainable\n     *\n     *  @param {String} [flags='gimu'] - Regular Expression flags to be removed.\n     *  If omitted, all flags are removed.\n     *  @returns {re}\n     */\n    removeFlags(flags = 'gimu') {\n        // if falsy, remove all flags\n        let f = this.flags();\n        flags.split('').forEach(char => {\n            f = f.replace(new RegExp(char, 'g'), '');\n        });\n        this.regexp = new RegExp(this.regexp.source, f);\n        return this;\n    }\n\n    /**\n     *  Gets a clone of the internal `RegExp` instance.\n     *  @name re.clone\n     *  @function\n     *\n     *  @returns {RegExp}\n     */\n    clone() {\n        return _cloneRegExp(this.regexp);\n    }\n\n    /**\n     *  Like `Array#forEach`, invokes the given callback on each `RegExp#exec`\n     *  call. The `callback` is invoked with three arguments:\n     *  `(matches:Array, index:Number, regexp:RegExp)`.\n     *\n     *  Callback functions may exit iteration early by explicitly returning\n     *  `false`.\n     *\n     *  @name re.each\n     *  @function\n     *\n     *  @param {String} input - Source input string.\n     *  @param {Function} callback - The function invoked per iteration.\n     *         This takes four arguments.\n     *         See {@link ?api=re#re~callback|`callback`}.\n     *  @returns {void}\n     *\n     *  @example\n     *  var input = 'Peter Piper picked a peck of pickled peppers.';\n     *  re(/p\\w+/i).each(input, function (matches, index, regexp, charIndex) {\n     *      console.log(matches[0]); // logs words starting with a \"p\"\n     *  });\n     */\n    each(input, callback) {\n        // Note: Do not place the regular expression literal (or RegExp\n        // constructor) within the while condition or it will create an infinite\n        // loop if there is a match due to the lastIndex property being reset\n        // upon each iteration. Also be sure that the global flag is set or a\n        // loop will occur here either.\n        if (!this.regexp.global) this.addFlags('g');\n        let matches,\n            index = 0;\n        while ((matches = this.regexp.exec(input)) !== null) {\n            if (callback(matches, index, this.regexp, matches.index) === false) break;\n            index++;\n        }\n        // reset when we're done!\n        this._reset();\n    }\n\n    /**\n     *  Like `re#each` except that it iterates over matches of collection from\n     *  right to left (in other words, last to first).\n     *\n     *  Callback functions may exit iteration early by explicitly returning\n     *  `false`.\n     *\n     *  @name re.eachRight\n     *  @function\n     *\n     *  @param {String} input - Source input string.\n     *  @param {Function} callback - The function invoked per iteration.\n     *         This takes four arguments.\n     *         See {@link ?api=re#re~callback|`callback`}.\n     *  @returns {void}\n     *\n     *  @example\n     *  var input = 'Peter Piper picked a peck of pickled peppers.';\n     *  re(/p\\w+/i).eachRight(input, function (matches, index) {\n     *      if (matches[0] === 'peck') {\n     *          console.log('exiting @', index); // —> exiting @ 3\n     *          // return early, no more iterations..\n     *          return false;\n     *      }\n     *  });\n     */\n    eachRight(input, callback) {\n        let i,\n            arr = this.map(input);\n        for (i = arr.length - 1; i >= 0; i--) {\n            if (callback(arr[i], i, this.regexp) === false) break;\n        }\n    }\n\n    /**\n     *  Like `re#each` except that this will iterate over non-matched blocks.\n     *\n     *  Callback functions may exit iteration early by explicitly returning\n     *  `false`.\n     *\n     *  <b>Remark</b>: This is an experimental feature.\n     *\n     *  @name re.eachInverse\n     *  @function\n     *\n     *  @param {String} input - Source input string.\n     *  @param {Function} callback - The function invoked per iteration.\n     *         This takes four arguments.\n     *         See {@link ?api=re#re~callback|`callback`}.\n     *  @returns {void}\n     *\n     *  @example\n     *  var input = 'foo1bar2baz';\n     *  re(/\\d/i).eachInverse(input, function (matches, index) {\n     *      if (index === 1) {\n     *          console.log(matches[0]); // —> \"bar\"\n     *          // return early, no more iterations..\n     *          return false;\n     *      }\n     *  });\n     */\n    eachInverse(input, callback) {\n        if (!this.regexp.global) this.addFlags('g');\n        let invMatch,\n            matches,\n            lastCharIndex = -1,\n            index = 0,\n            broke = false;\n\n        // NOTE: `invMatch` will be a string but we'll make it an array for\n        // consistency with other methods.\n\n        while ((matches = this.regexp.exec(input)) !== null) {\n            // check if first match character is 0 or not\n            if (index === 0 && matches.index > 0) {\n                // take the first offset as the first inverse match\n                invMatch = input.slice(0, matches.index);\n                broke = callback([invMatch], index, this.regexp, matches.index) === false;\n                if (broke) break;\n            }\n            // this will run after the first iteration\n            if (lastCharIndex > 0) {\n                invMatch = input.slice(lastCharIndex, matches.index);\n                broke = callback([invMatch], index, this.regexp, matches.index) === false;\n                if (broke) break;\n            }\n            // set the last character index of the current match for later use\n            lastCharIndex = matches.index + (matches[0] || '').length;\n            index++;\n        }\n        // check if we have remaining sub-string after the last exec match.\n        // we should run this only if user didn't break (return false) before.\n        if (!broke && lastCharIndex <= input.length - 1) {\n            invMatch = input.slice(lastCharIndex, input.length);\n            callback([invMatch], index, this.regexp, lastCharIndex);\n        }\n        // reset when we're done!\n        this._reset();\n    }\n\n    /**\n     *  Like `Array#map`, maps the results of each `RegExp#exec` iteration while\n     *  invoking the given callback function on each match.\n     *  @name re.map\n     *  @function\n     *\n     *  @param {String} input - Source input string.\n     *  @param {Function} [callback] - The function invoked per iteration.\n     *         This takes four arguments.\n     *         See {@link ?api=re#re~callback|`callback`}.\n     *         If omitted, `matches` will be returned on each iteration.\n     *         Note that each match is also an `Array` containing the entire\n     *         match result and any parentheses-captured matched results.\n     *  @returns {Array}\n     *           Array of mapped matches (modified via `callback` if defined).\n     *           Returns an empty `Array` if there were no matches.\n     *\n     *  @example\n     *  var mapped = re(/p\\w+/i).map(input, function (matches) {\n     *      return matches[0];\n     *  });\n     *  console.log(mapped);\n     *  // —> [\"Peter\", \"Piper\", \"picked\", \"peck\", \"pickled\", \"peppers\"]\n     */\n    map(input, callback) {\n        if (!this.regexp.global) this.addFlags('g');\n        let matches,\n            result = [],\n            index = 0,\n            hasCallback = typeof callback === 'function';\n        while ((matches = this.regexp.exec(input)) !== null) {\n            // each iteration returns an array, we'll pass that and the\n            // regexp instance to the invoked callback.\n            result.push(\n                hasCallback\n                    ? callback(matches, index, this.regexp, matches.index)\n                    : matches\n            );\n            index++;\n        }\n        return result;\n    }\n\n    /**\n     *  Gets all the matches within the given input string, at once.\n     *  Same as `re#map(input)` (with no callback) which returns all matches.\n     *  @name re.all\n     *  @function\n     *\n     *  @param {String} input - Source input string.\n     *  @returns {Array}\n     *           Array of matches. Returns an empty `Array` if there were no\n     *           matches. Note that each match is also an `Array` containing the\n     *           entire match result and any parentheses-captured matched results.\n     *\n     *  @example\n     *  re(/p\\w+/i).all('Peter picked peppers');\n     *  // —> [Array, Array, Array]\n     */\n    all(input) {\n        return this.map(input);\n    }\n\n    /**\n     *  Returns a chainable  object that provides a `.next()` method to be\n     *  called repeatedly, to re-execute the `RegExp` against the input string.\n     *\n     *  The `.next()` method takes a single `callback` argument.\n     *  See {@link ?api=re#re~callback|`callback`}.\n     *\n     *  @name re.exec\n     *  @function\n     *\n     *  @param {String} input - Source input string.\n     *  @returns {Exec}\n     *\n     *  @example\n     *  re(/p\\w+/i)\n     *      .exec('Peter picked peppers')\n     *      .next(function (matches, index) {\n     *          console.log(index + ':', matches[0]); // —> 0: \"Peter\"\n     *      })\n     *      .next(function (matches, index) {\n     *          console.log(index, ':', matches[0]); // —> 1: \"picked\"\n     *      })\n     *      ..\n     */\n    exec(input) {\n        return new Exec(this.regexp, input);\n    }\n\n    /**\n     *  Executes a search for a match within the given input string.\n     *  Returns `true` or `false`.\n     *  @name re.test\n     *  @function\n     *\n     *  @param {String} input - Source input string.\n     *  @returns {Boolean}\n     *\n     *  @example\n     *  re(/p\\w+/i).test('Peter picked peppers'); // —> true\n     */\n    test(input) {\n        return this.regexp.test(input);\n    }\n\n    /**\n     *  Gets the global number of matches within the given input string.\n     *  @name re.count\n     *  @function\n     *\n     *  @param {String} input - Source input string.\n     *  @returns {Number}\n     *\n     *  @example\n     *  re(/p\\w+/i).count('Peter picked peppers'); // —> 3\n     */\n    count(input) {\n        return this.all(input).length;\n    }\n\n    /**\n     *  Similar to `String#match()`, retreives the matches within the given\n     *  input string.\n     *  @name re.match\n     *  @function\n     *\n     *  @param {String} input - Source input string.\n     *  @returns {Array<String>}\n     *           An Array containing the entire match result and any\n     *           parentheses-captured matched results, or `null` if there were\n     *           no matches.\n     *\n     *  @example\n     *  re(/p\\w+/i).match('Peter picked peppers');\n     *  // —> [\"Peter\", \"picked\", \"peppers\"]\n     */\n    match(input) {\n        return input.match(this.regexp) || [];\n    }\n\n    /**\n     *  Gets the first match within the given input string.\n     *  Returns `null` if not found.\n     *  @name re.first\n     *  @function\n     *\n     *  @param {String} input - Source input string.\n     *  @param {Number} [startPosition=0] - Character position index to start with.\n     *  @returns {Array}\n     *           First match. The returned array has the matched text as the\n     *           first item, and then one item for each capturing parenthesis\n     *           that matched containing the text that was captured.\n     *\n     *  @example\n     *  re(/p\\w+/i).first('Peter picked peppers')[0]; // —> \"Peter\"\n     */\n    first(input, startPosition = 0) {\n        let matches = this.regexp.exec(input.substr(startPosition));\n        this._reset();\n        return matches || [];\n    }\n\n    /**\n     *  Gets the character position index of the first match against the given\n     *  input string.\n     *  @name re.firstIndex\n     *  @function\n     *\n     *  @param {String} input - Source input string.\n     *  @param {Number} [startPosition=0] - Character position index to start with.\n     *  @returns {Number} - Character position index of the first matched result.\n     *\n     *  @example\n     *  re(/p\\w+/i).firstIndex('Peter picked peppers'); // —> 0\n     */\n    firstIndex(input, startPosition = 0) {\n        return input.substr(startPosition).search(this.regexp);\n    }\n\n    /**\n     *  Gets the match at the given (match) index within the given input string.\n     *  Returns `null` if not found.\n     *  @name re.nth\n     *  @function\n     *\n     *  @param {String} input - Source input string.\n     *  @param {Number} [startPosition=0] - Character position index to start with.\n     *  @returns {Array}\n     *           Match at the given index. The returned array has the matched\n     *           text as the first item, and then one item for each capturing\n     *           parenthesis that matched containing the text that was captured.\n     *\n     *  @example\n     *  re(/p\\w+/i).nth('Peter picked peppers', 1)[0]; // —> \"picked\"\n     */\n    nth(input, index = 0, startPosition = 0) {\n        input = input.substr(startPosition);\n        if (index < 0) return null;\n        let result = this.all(input);\n        if (!result.length || index >= result.length) return null;\n        return result[index];\n    }\n\n    /**\n     *  Gets the last match within the given input string.\n     *  Returns `null` if not found.\n     *  @name re.last\n     *  @function\n     *\n     *  @param {String} input - Source input string.\n     *  @param {Number} [startPosition=0] - Character position index to start with.\n     *  @returns {Array}\n     *           Last match. The returned array has the matched text as the\n     *           first item, and then one item for each capturing parenthesis\n     *           that matched containing the text that was captured.\n     *\n     *  @example\n     *  re(/p\\w+/i).last('Peter picked peppers')[0]; // —> \"peppers\"\n     */\n    last(input) {\n        let all = this.all(input);\n        return all.length\n            ? all[all.length - 1]\n            : null;\n    }\n\n    /**\n     *  Gets the character position index of the last match against the given\n     *  input string.\n     *  @name re.lastIndex\n     *  @function\n     *\n     *  @param {String} input - Source input string.\n     *  @param {Number} [startPosition=0] - Character position index to start with.\n     *  @returns {Number} - Character position index of the last matched result.\n     *\n     *  @example\n     *  re(/p\\w+/i).lastIndex('Peter picked peppers'); // —> 13\n     */\n    lastIndex(input, startPosition = 0) {\n        let result = this.all(input);\n        if (result.length) {\n            let lastIndex = result[result.length - 1].index;\n            return lastIndex > startPosition\n                ? lastIndex - startPosition\n                : -1;\n        }\n        return -1;\n    }\n\n    /**\n     *  Gets character position indices of all the matches against the given\n     *  input string.\n     *  @name re.indices\n     *  @alias re.charIndices\n     *  @function\n     *\n     *  @param {String} input - Source input string.\n     *  @param {Number} [startPosition=0] - Character position index to start with.\n     *  @returns {Array<Number>}\n     *           An array of numbers that indicate all the matched character\n     *           position indices.\n     *\n     *  @example\n     *  re(/p\\w+/i).indices('Peter picked peppers');\n     *  // —> [0, 6, 13]\n     */\n    indices(input, startPosition = 0) {\n        let arr = [];\n        this.each(input, (matches, index, regexp, charIndex) => {\n            if (startPosition <= charIndex) arr.push(charIndex);\n        });\n        return arr;\n    }\n\n    /**\n     *  Alias of `re#indices`.\n     *  @private\n     */\n    charIndices(input, startPosition = 0) {\n        return this.indices(input, startPosition);\n    }\n}\n\n// --------------------------\n// re OBJECT\n// --------------------------\n\n/**\n *  `RegExp` API for Humans!\n *\n *  For example, if you place regular expression literal or `RegExp` constructor\n *  within a `while` condition, you'll hit an infinite loop if there is a match!\n *  (Because the `RegExp` instance is re-initiated every time; which resets\n *  `lastIndex` to `0`).\n *\n *  Or if you forget the `global` flag for a `RegExp#exec()` call in a `while`\n *  condition; you'll again, hit an infinite loop!\n *\n *  Using `re`, you don't need to deal with these.\n *\n *  `re` is a shorthand function for initializing an instance of the internal\n *  `RE` class. You can init an instance with a `RegExp` literal or just like\n *  the `RegExp` constructor, pass two string arguments for pattern and flags.\n *\n *  @name re\n *  @function\n *  @global\n *\n *  @param {RegExp|String} pattern - Either a `RegExp` instance or\n *  string pattern.\n *  @param {String} [flags=\"\"] - Regular Expression flags. Ignored if a\n *  `RegExp` instance is passed as the first argument.\n *  @returns {RE} - `RE` instance.\n *\n *  @example\n *  re(/\\w+/gm).test('input');\n *  // or\n *  re('\\\\w+', 'gm').test('input');\n */\nfunction re(pattern, flags) {\n    return new RE(pattern, flags);\n}\n\n/**\n *  Checks whether the given object is a `RegExp`.\n *  @function\n *\n *  @param {*} object - Object to be checked.\n *  @returns {Boolean}\n */\nre.isRegExp = _isRegExp;\n\n/**\n *  Escapes regular expression characters within the given string.\n *  @function\n *\n *  @param {String} pattern - Pattern string to be escaped.\n *  @returns {String}\n */\nre.escape = _escapeRegExp;\n\nre.RE = RE;\n\n// --------------------------\n// EXPORT\n// --------------------------\n\nexport default re;\n\n// --------------------------\n// ADDITIONAL DOCUMENTATION\n// --------------------------\n\n/**\n *  Callback function to be passed as an argument to methods such as\n *  {@link ?api=re#re#each|`re#each`}, {@link ?api=re#re#map|`re#map`}, etc..\n *  This is invoked per `RegExp` iteration with the following signature:\n *\n *  `function (matches:Array, index:Number, regexp:RegExp, charIndex:Number) {...}`\n *\n *  @callback re~callback\n *\n *  @param {Array} [matches]\n *         An `Array` containing the entire match result and any\n *         parentheses-captured matched results.\n *  @param {Number} [index]\n *         Current match (iteration) index.\n *  @param {RegExp} [regexp]\n *         Internal `RegExp` instance being used through out the iteration.\n *  @param {Number} [charIndex]\n *         Character index of the matched string.\n *         Same as `regexp.lastIndex` or `matches.index`.\n */\n\n\n\n// WEBPACK FOOTER //\n// ./src/re.js"],"sourceRoot":""}