{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 4bab09b80dedc5be584f","webpack:///./src/index.js","webpack:///./src/re.js"],"names":[],"mappings":"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","file":"re.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"re\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"re\"] = factory();\n\telse\n\t\troot[\"re\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 4bab09b80dedc5be584f\n **/","import re from './re';\n// export default re;\n// http://stackoverflow.com/a/33683495/112731\nmodule.exports = re;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","'use strict';\n\n/**\n *  re.js — RegExp API for Humans!\n *  @license MIT\n *  @copyright 2016, Onur Yıldırım (onur@cutepilot.com)\n */\n\n// --------------------------\n// HELPER METHODS\n// --------------------------\n\n/**\n *  Escapes regular expression characters within the given string.\n *  @private\n */\nfunction _escapeRegExp(pattern) {\n    return pattern.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n}\n\n/**\n *  Checks whether the given object is a `RegExp`.\n *  @private\n */\nfunction _isRegExp(object) {\n    return Object.prototype.toString.call(object) === '[object RegExp]';\n}\n\n/**\n *  Gets the current flags from a `RegExp` instance.\n *  @private\n */\nfunction _getRegExpFlags(regexp) {\n    return regexp.toString().match(/[gimu]*$/)[0] || '';\n}\n\n/**\n *  Ensures that a `RegExp` instance has the given flag(s).\n *  @private\n */\nfunction _addFlags(regexp, flags) {\n    flags = _uniqChars(flags + _getRegExpFlags(regexp));\n    return new RegExp(regexp.source, flags);\n}\n\n/**\n *  Clones the given `RegExp` object.\n *  @private\n */\nfunction _cloneRegExp(regexp) {\n    return new RegExp(regexp.source, _getRegExpFlags(regexp));\n}\n\n/**\n *  Removes duplicate characters from the given string.\n *  @private\n */\nfunction _uniqChars(str) {\n    // we're safe to use .split here since we don't have unicode chars in 'gimu'.\n    // http://stackoverflow.com/a/38901550/112731\n    let arr = str.split('');\n    return arr.filter((value, index, list) => {\n        return list.indexOf(value) === index;\n    }).join('');\n}\n\n// --------------------------\n// CLASS: Exec\n// --------------------------\n\n/**\n *  Internal `Exec` class used specifically for `re().exec()` method.\n *  @protected\n *  @inner\n *  @memberof! re\n */\nclass Exec {\n\n    /**\n     *  Initiates a new instance of `Exec` class.\n     *  @private\n     *\n     *  @param {RegExp} regexp - RegExp instance.\n     *  @param {String} input - Source input string.\n     */\n    constructor(regexp, input) {\n        this.regexp = regexp;\n        this.input = input;\n        // this is used to store the .exec() call count/index\n        this.nextIndex = 0;\n    }\n\n    /**\n     *  Calls `RegExp#exec()` method once, for the current input string.\n     *  @private\n     *\n     *  @param {Function} callback\n     *  @returns {Exec} - Returns the current `Exec` instance (for\n     *  chainability and) so that `.next()` can be called repeatedly.\n     */\n    next(callback) {\n        if (!this.regexp.global) {\n            this.regexp = _addFlags(this.regexp, 'g');\n        }\n        let matches = this.regexp.exec(this.input);\n        callback(matches, this.nextIndex, this.regexp);\n        // if exec matches are complete, reset `nextIndex` here. if not,\n        // user should call .reset() at the end of `.exec()` chain; if willing\n        // to reuse the RE instance.\n        if (this.regexp.lastIndex === 0) {\n            this.nextIndex = 0;\n        } else {\n            this.nextIndex++;\n        }\n        return this;\n    }\n\n    /**\n     *  Resets the last index of the internal `RegExp` instance.\n     *  This is for convenience that if the user wants to re-use the `Exec`\n     *  instance, they should call `.reset()` to reset the `.lastIndex`.\n     *  @private\n     *\n     *  @example\n     *  re(/\\w+/).exec(str)\n     *      .next(function (matches, index) {\n     *          console.log(index); // 0\n     *      })\n     *      .next(function (matches, index) {\n     *          console.log(index); // 1\n     *      })\n     *      .reset()\n     *      .next(function (matches, index) {\n     *          console.log(index); // 0\n     *      });\n     */\n    reset() {\n        // reset exec count/index\n        this.nextIndex = 0;\n        // `.lastIndex` property is set only if the regular expression instance\n        // used the `g` flag to indicate a global search.\n        if (this.regexp.global && this.regexp.lastIndex) this.regexp.lastIndex = 0;\n        return this;\n    }\n}\n\n// --------------------------\n// CLASS: RE\n// --------------------------\n\n/**\n *  `RE` internal class.\n *  @private\n *\n *  @license MIT\n *  @copyright 2016, Onur Yıldırım (onur@cutepilot.com)\n */\nclass RE {\n\n    /**\n     *  Initiates a new instance of `RE`.\n     *  @private\n     *\n     *  @param {RegExp|String} pattern - Either a `RegExp` instance or\n     *  string pattern.\n     *  @param {String} [flags=\"\"] - Regular Expression flags. Ignored if a\n     *  `RegExp` instance is passed as the first argument.\n     */\n    constructor(pattern, flags) {\n        this.input = '';\n        this.regexp = !_isRegExp(pattern)\n            ? new RegExp(pattern, flags || '')\n            // if a RegExp instance is passed, it will be untouched. flags,\n            // lastIndex, etc will be changed only on the internal clone, if\n            // needed.\n            : _cloneRegExp(pattern);\n\n        // reset `.lastIndex`. the passed regexp might be used previously.\n        this._reset();\n    }\n\n    /**\n     *  Resets the last index of the internal `RegExp` instance.\n     *  @private\n     */\n    _reset() {\n        // `.lastIndex` property is set only if the regular expression instance\n        // used the `g` flag to indicate a global search.\n        if (this.regexp.global && this.regexp.lastIndex) this.regexp.lastIndex = 0;\n    }\n\n    /**\n     *  Gets or sets the flags of the internal `RegExp` instance.\n     *  Omit the `value` argument to get the current flags.\n     *  @name re#flags\n     *  @function\n     *\n     *  @param {String} [value] - Regular Expression flags to be set.\n     *  @returns {String|void}\n     */\n    flags(value) {\n        if (value === undefined) {\n            return _getRegExpFlags(this.regexp);\n        }\n        this.regexp = new RegExp(this.regexp.source, value);\n    }\n\n    /**\n     *  Ensures that the internal `RegExp` instance has the given flag(s).\n     *  You shouldn't need to call this. This method is mostly used internally\n     *  and made accessible as a convenience method.\n     *  @name re#addFlags\n     *  @function\n     *  @chainable\n     *\n     *  @param {String} flags - Regular Expression flags to be added.\n     *  @returns {re}\n     */\n    addFlags(flags) {\n        this.regexp = _addFlags(this.regexp, flags);\n        return this;\n    }\n\n    /**\n     *  Removes the given flags from the internal `RegExp` instance.\n     *  You shouldn't need to call this. This is only made accessible as a\n     *  convenience method.\n     *  @name re#removeFlags\n     *  @function\n     *  @chainable\n     *\n     *  @param {String} [flags='gimu'] - Regular Expression flags to be removed.\n     *  If omitted, all flags are removed.\n     *  @returns {re}\n     */\n    removeFlags(flags = 'gimu') {\n        // if falsy, remove all flags\n        let f = this.flags();\n        flags.split('').forEach(char => {\n            f = f.replace(new RegExp(char, 'g'), '');\n        });\n        this.regexp = new RegExp(this.regexp.source, f);\n        return this;\n    }\n\n    /**\n     *  Gets a clone of the internal `RegExp` instance.\n     *  @name re#clone\n     *  @function\n     *\n     *  @returns {RegExp}\n     */\n    clone() {\n        return _cloneRegExp(this.regexp);\n    }\n\n    /**\n     *  Like `Array#forEach`, invokes the given callback on each `RegExp#exec`\n     *  call. The `callback` is invoked with three arguments:\n     *  `(matches:Array, index:Number, regexp:RegExp)`.\n     *\n     *  Callback functions may exit iteration early by explicitly returning\n     *  `false`.\n     *\n     *  @name re#each\n     *  @function\n     *\n     *  @param {String} input - Source input string.\n     *  @param {Function} callback - The function invoked per iteration.\n     *         This takes three arguments.\n     *         See {@link ?api=re#re~callback|`callback`}.\n     *  @returns {void}\n     *\n     *  @example\n     *  var input = 'Peter Piper picked a peck of pickled peppers.';\n     *  re(/p\\w+/i).each(input, function (matches) {\n     *      console.log(matches[0]); // logs words starting with a \"p\"\n     *  });\n     */\n    each(input, callback) {\n        // Note: Do not place the regular expression literal (or RegExp\n        // constructor) within the while condition or it will create an infinite\n        // loop if there is a match due to the lastIndex property being reset\n        // upon each iteration. Also be sure that the global flag is set or a\n        // loop will occur here also.\n        if (!this.regexp.global) this.addFlags('g');\n        let matches,\n            index = 0;\n        while ((matches = this.regexp.exec(input)) !== null) {\n            if (callback(matches, index, this.regexp) === false) break;\n            index++;\n        }\n        // reset when we're done!\n        this._reset();\n    }\n\n    /**\n     *  Like `re#each` except that it iterates over matches of collection from\n     *  right to left (in other words, last to first).\n     *\n     *  Callback functions may exit iteration early by explicitly returning\n     *  `false`.\n     *\n     *  @name re#eachRight\n     *  @function\n     *\n     *  @param {String} input - Source input string.\n     *  @param {Function} callback - The function invoked per iteration.\n     *         This takes three arguments.\n     *         See {@link ?api=re#re~callback|`callback`}.\n     *  @returns {void}\n     *\n     *  @example\n     *  var input = 'Peter Piper picked a peck of pickled peppers.';\n     *  re(/p\\w+/i).eachRight(input, function (matches, index) {\n     *      if (matches[0] === 'peck') {\n     *          console.log('exiting @', index); // —> exiting @ 2\n     *          // return early, no more iterations..\n     *          return false;\n     *      }\n     *  });\n     */\n    eachRight(input, callback) {\n        let i,\n            arr = this.map(input),\n            index = 0;\n        for (i = arr.length - 1; i >= 0; i--) {\n            if (callback(arr[i], index, this.regexp) === false) break;\n            index++;\n        }\n    }\n\n    /**\n     *  Like `Array#map`, maps the results of each `RegExp#exec` iteration while\n     *  invoking the given callback function on each match.\n     *  @name re#map\n     *  @function\n     *\n     *  @param {String} input - Source input string.\n     *  @param {Function} [callback] - The function invoked per iteration.\n     *         This takes three arguments.\n     *         See {@link ?api=re#re~callback|`callback`}.\n     *         If omitted, `matches` will be returned on each iteration.\n     *         Note that each match is also an `Array` containing the entire\n     *         match result and any parentheses-captured matched results.\n     *  @returns {Array}\n     *           Array of mapped matches. Returns an empty `Array` if there were\n     *           no matches.\n     *\n     *  @example\n     *  var mapped = re(/p\\w+/i).map(input, function (matches) {\n     *      return matches[0];\n     *  });\n     *  console.log(mapped);\n     *  // —> [\"Peter\", \"Piper\", \"picked\", \"peck\", \"pickled\", \"peppers\"]\n     */\n    map(input, callback) {\n        if (!this.regexp.global) this.addFlags('g');\n        let matches,\n            result = [],\n            index = 0,\n            hasCallback = typeof callback === 'function';\n        while ((matches = this.regexp.exec(input)) !== null) {\n            // each iteration returns an array, we'll pass that and the\n            // regexp instance to the invoked callback.\n            result.push(hasCallback ? callback(matches, index, this.regexp) : matches);\n            index++;\n        }\n        return result;\n    }\n\n    /**\n     *  Gets all the matches within the given input string, at once.\n     *  Same as `re#map(input)` (with no callback) which returns all matches\n     *  without altering matched items.\n     *  @name re#all\n     *  @function\n     *\n     *  @param {String} input - Source input string.\n     *  @returns {Array}\n     *           Array of matches. Returns an empty `Array` if there were no\n     *           matches. Note that each match is also an `Array` containing the\n     *           entire match result and any parentheses-captured matched results.\n     *\n     *  @example\n     *  re(/p\\w+/i).all('Peter picked peppers');\n     *  // —> [Array, Array, Array]\n     */\n    all(input) {\n        return this.map(input);\n    }\n\n    /**\n     *  Returns a chainable  object that provides a `.next()` method to be\n     *  called repeatedly, to re-execute the `RegExp` against the input string.\n     *\n     *  The `.next()` method takes a single `callback` argument.\n     *  See {@link ?api=re#re~callback|`callback`}.\n     *\n     *  @name re#exec\n     *  @function\n     *\n     *  @param {String} input - Source input string.\n     *  @returns {Exec}\n     *\n     *  @example\n     *  re(/p\\w+/i)\n     *      .exec('Peter picked peppers')\n     *      .next(function (matches, index) {\n     *          console.log(index + ':', matches[0]); // —> 0: \"Peter\"\n     *      })\n     *      .next(function (matches, index) {\n     *          console.log(index, ':', matches[0]); // —> 1: \"picked\"\n     *      })\n     *      ..\n     */\n    exec(input) {\n        return new Exec(this.regexp, input);\n    }\n\n    /**\n     *  Executes a search for a match within the given input string.\n     *  Returns `true` or `false`.\n     *  @name re#test\n     *  @function\n     *\n     *  @param {String} input - Source input string.\n     *  @returns {Boolean}\n     *\n     *  @example\n     *  re(/p\\w+/i).test('Peter picked peppers'); // —> true\n     */\n    test(input) {\n        return this.regexp.test(input);\n    }\n\n    /**\n     *  Gets the global number of matches within the given input string.\n     *  @name re#count\n     *  @function\n     *\n     *  @param {String} input - Source input string.\n     *  @returns {Number}\n     *\n     *  @example\n     *  re(/p\\w+/i).count('Peter picked peppers'); // —> 3\n     */\n    count(input) {\n        return this.all(input).length;\n    }\n\n    /**\n     *  Similar to `String#match()`, retreives the matches within the given\n     *  input string.\n     *  @name re#match\n     *  @function\n     *\n     *  @param {String} input - Source input string.\n     *  @returns {Array}\n     *           An Array containing the entire match result and any\n     *           parentheses-captured matched results, or `null` if there were\n     *           no matches.\n     *\n     *  @example\n     *  re(/p\\w+/i).match('Peter picked peppers');\n     *  // —> [\"Peter\", \"picked\", \"peppers\"]\n     */\n    match(input) {\n        return input.match(this.regexp) || [];\n    }\n\n    /**\n     *  Gets the first match within the given input string.\n     *  Returns `null` if not found.\n     *  @name re#first\n     *  @function\n     *\n     *  @param {String} input - Source input string.\n     *  @param {Number} [startPosition=0] - Character position index to start with.\n     *  @returns {Array}\n     *           First match. The returned array has the matched text as the\n     *           first item, and then one item for each capturing parenthesis\n     *           that matched containing the text that was captured.\n     *\n     *  @example\n     *  re(/p\\w+/i).first('Peter picked peppers'); // —> \"Peter\"\n     */\n    first(input, startPosition = 0) {\n        let matches = this.regexp.exec(input.substr(startPosition));\n        this._reset();\n        return matches;\n    }\n\n    /**\n     *  Gets the character position index of the first match against the given\n     *  input string.\n     *  @name re#firstIndex\n     *  @function\n     *\n     *  @param {String} input - Source input string.\n     *  @param {Number} [startPosition=0] - Character position index to start with.\n     *  @returns {Number} - Character position index of the first matched result.\n     *\n     *  @example\n     *  re(/p\\w+/i).firstIndex('Peter picked peppers'); // —> 0\n     */\n    firstIndex(input, startPosition = 0) {\n        return input.substr(startPosition).search(this.regexp);\n    }\n\n    /**\n     *  Gets the match at the given (match) index within the given input string.\n     *  Returns `null` if not found.\n     *  @name re#nth\n     *  @function\n     *\n     *  @param {String} input - Source input string.\n     *  @param {Number} [startPosition=0] - Character position index to start with.\n     *  @returns {Array}\n     *           Match at the given index. The returned array has the matched\n     *           text as the first item, and then one item for each capturing\n     *           parenthesis that matched containing the text that was captured.\n     *\n     *  @example\n     *  re(/p\\w+/i).nth('Peter picked peppers', 1); // —> \"picked\"\n     */\n    nth(input, index = 0, startPosition = 0) {\n        input = input.substr(startPosition);\n        if (index < 0) return null;\n        let result = this.all(input);\n        if (!result.length || index >= result.length) return null;\n        return result[index];\n    }\n\n    /**\n     *  Gets the last match within the given input string.\n     *  Returns `null` if not found.\n     *  @name re#last\n     *  @function\n     *\n     *  @param {String} input - Source input string.\n     *  @param {Number} [startPosition=0] - Character position index to start with.\n     *  @returns {Array}\n     *           Last match. The returned array has the matched text as the\n     *           first item, and then one item for each capturing parenthesis\n     *           that matched containing the text that was captured.\n     *\n     *  @example\n     *  re(/p\\w+/i).last('Peter picked peppers'); // —> \"peppers\"\n     */\n    last(input) {\n        let all = this.all(input);\n        return all.length\n            ? all[all.length - 1]\n            : null;\n    }\n\n    /**\n     *  Gets the character position index of the last match against the given\n     *  input string.\n     *  @name re#lastIndex\n     *  @function\n     *\n     *  @param {String} input - Source input string.\n     *  @param {Number} [startPosition=0] - Character position index to start with.\n     *  @returns {Number} - Character position index of the last matched result.\n     *\n     *  @example\n     *  re(/p\\w+/i).lastIndex('Peter picked peppers'); // —> 13\n     */\n    lastIndex(input, startPosition = 0) {\n        let result = this.all(input);\n        if (result.length) {\n            let lastIndex = result[result.length - 1].index;\n            return lastIndex > startPosition\n                ? lastIndex - startPosition\n                : -1;\n        }\n        return -1;\n    }\n\n    /**\n     *  Gets character position indices of all the matches against the given\n     *  input string.\n     *  @name re#indices\n     *  @function\n     *\n     *  @param {String} input - Source input string.\n     *  @param {Number} [startPosition=0] - Character position index to start with.\n     *  @returns {Array<Number>}\n     *           An array of numbers that indicate all the matched character\n     *           position indices.\n     *\n     *  @example\n     *  re(/p\\w+/i).indices('Peter picked peppers');\n     *  // —> [0, 6, 13]\n     */\n    indices(input, startPosition = 0) {\n        let arr = [];\n        this.each(input, matches => {\n            if (startPosition <= matches.index) arr.push(matches.index);\n        });\n        return arr;\n    }\n}\n\n// --------------------------\n// re OBJECT\n// --------------------------\n\n/**\n *  `RegExp` API for Humans!\n *\n *  `re` is a shorthand function for initializing an instance of the internal\n *  `RE` class. You can init an instance with a `RegExp` literal or just like\n *  the `RegExp` constructor, pass two string arguments for pattern and flags.\n *\n *  @name re\n *  @function\n *  @global\n *\n *  @param {RegExp|String} pattern - Either a `RegExp` instance or\n *  string pattern.\n *  @param {String} [flags=\"\"] - Regular Expression flags. Ignored if a\n *  `RegExp` instance is passed as the first argument.\n *  @returns {RE} - `RE` instance.\n *\n *  @example\n *  re(/\\w+/gm).test('input');\n *  // or\n *  re('\\\\w+', 'gm').test('input');\n */\nfunction re(pattern, flags) {\n    return new RE(pattern, flags);\n}\n\n/**\n *  Checks whether the given object is a `RegExp`.\n *  @function\n *\n *  @param {*} object - Object to be checked.\n *  @returns {Boolean}\n */\nre.isRegExp = _isRegExp;\n\n/**\n *  Escapes regular expression characters within the given string.\n *  @function\n *\n *  @param {String} pattern - Pattern string to be escaped.\n *  @returns {String}\n */\nre.escape = _escapeRegExp;\n\nre.RE = RE;\n\n// --------------------------\n// EXPORT\n// --------------------------\n\nexport default re;\n\n// --------------------------\n// ADDITIONAL DOCUMENTATION\n// --------------------------\n\n/**\n *  Callback function to be passed as an argument to methods such as\n *  {@link ?api=re#re#each|`re#each`}, {@link ?api=re#re#map|`re#map`}, etc..\n *  This is invoked per `RegExp` iteration with the following signature:\n *\n *  `function (matches:Array, index:Number, regexp:RegExp) {...}`\n *\n *  @callback re~callback\n *\n *  @param {Array} [matches]\n *         An `Array` containing the entire match result and any\n *         parentheses-captured matched results. This object also has an\n *         `.index` property indicating the current match's position.\n *  @param {Number} [index]\n *         Iteration index. For character position index use `matches.index` or\n *         `regexp.lastIndex`.\n * @param {RegExp} [regexp]\n *        Internal `RegExp` instance being used through out the iteration.\n */\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/re.js\n **/"],"sourceRoot":""}